[["text-mining.html", "3 Text Mining 3.1 Working with strings 3.2 Regular Expressions", " 3 Text Mining 3.1 Working with strings import this 3.1.1 String Types new_string = &quot;This is a String&quot; # storing a string print(f&#39;ID: {id(new_string)}&#39;) # shows the object identifier (address) ## ID: 4905180496 print(f&#39;Type: {type(new_string)}&#39;) # shows the object type (type(new_string) ## Type: &lt;class &#39;str&#39;&gt; print(f&#39;Value: {new_string}&#39;) # shows the object value ## Value: This is a String simple_string = &#39;Hello!&#39; + &quot; I&#39;m a simple string&quot; print(simple_string) # multi-line string, note the \\n (newline) escape character automatically created ## Hello! I&#39;m a simple string multi_line_string = &quot;&quot;&quot;Hello I&#39;m a multi-line string!&quot;&quot;&quot; multi_line_string ## &quot;Hello I&#39;m\\na multi-line\\nstring!&quot; print(multi_line_string) ## Hello I&#39;m ## a multi-line ## string! Be careful when writing raw strings, regex will escape them. # Normal string with escape sequences leading to a wrong file path! escaped_string = &quot;C:\\the_folder\\new_dir\\file.txt&quot; print(escaped_string) ## C: he_folder ## ew_dir ile.txt In order to keep the backslashes, use r'' to define a raw string: # raw string keeping the backslashes in its normal form raw_string = r&#39;C:\\the_folder\\new_dir\\file.txt&#39; print(raw_string) ## C:\\the_folder\\new_dir\\file.txt 3.1.2 Strings Operations # concatenation of variables and literals s1 = &#39;Python üíª!&#39; &#39;Hello üòä &#39; + s1 ## &#39;Hello üòä Python üíª!&#39; s1*5 ## &#39;Python üíª!Python üíª!Python üíª!Python üíª!Python üíª!&#39; # concatenating several strings together in parentheses s3 = (&#39;This &#39; &#39;is another way &#39; &#39;to concatenate &#39; &#39;several strings!&#39;) s3 ## &#39;This is another way to concatenate several strings!&#39; Checking for substrings in a string: &#39;way&#39; in s3, &#39;python&#39; in s3 ## (True, False) Computing total length of the string: len(s3) ## 51 3.1.3 Strings Conversion s = &#39;python is great&#39; s.capitalize(), s.upper(), s.title(), s.replace(&#39;python&#39;, &#39;R&#39;) ## (&#39;Python is great&#39;, &#39;PYTHON IS GREAT&#39;, &#39;Python Is Great&#39;, &#39;R is great&#39;) Checking for numbers and alphabet #.isdecimal() checks only for numeric strings &#39;12345&#39;.isdecimal(), &#39;apollo11&#39;.isdecimal() #.isalpha() checks only for numeric strings ## (True, False) &#39;python&#39;.isalpha(), &#39;number1&#39;.isalpha() #.isalpha() checks for alphanumeric strings, not just numeric strings ## (True, False) &#39;total&#39;.isalnum(),&#39;abc123&#39;.isalnum(), &#39;1+1&#39;.isalnum() ## (True, True, False) 3.1.4 String Indexing and Slicing s = &#39;PYTHON&#39; for index, character in enumerate(s): print(f&#39;Character -&gt; {character} has index-&gt; {index}&#39;) ## Character -&gt; P has index-&gt; 0 ## Character -&gt; Y has index-&gt; 1 ## Character -&gt; T has index-&gt; 2 ## Character -&gt; H has index-&gt; 3 ## Character -&gt; O has index-&gt; 4 ## Character -&gt; N has index-&gt; 5 s[0], s[1], s[2], s[3], s[4], s[5] ## (&#39;P&#39;, &#39;Y&#39;, &#39;T&#39;, &#39;H&#39;, &#39;O&#39;, &#39;N&#39;) s[:], s[1:4], s[:3], s[3:], s[-3:], s[:3] + s[-3:] ## (&#39;PYTHON&#39;, &#39;YTH&#39;, &#39;PYT&#39;, &#39;HON&#39;, &#39;HON&#39;, &#39;PYTHON&#39;) 3.1.5 String splitting and joining s = &#39;I,am,a,comma,separated,string&#39; s.split(&#39;,&#39;) ## [&#39;I&#39;, &#39;am&#39;, &#39;a&#39;, &#39;comma&#39;, &#39;separated&#39;, &#39;string&#39;] &#39; &#39;.join(s.split(&#39;,&#39;)) ## &#39;I am a comma separated string&#39; # stripping whitespace characters s = &#39; I am surrounded by spaces &#39; s, s.strip() ## (&#39; I am surrounded by spaces &#39;, &#39;I am surrounded by spaces&#39;) s = &#39;Python is great. NLP is also good.&#39; s.split(&#39;.&#39;) ## [&#39;Python is great&#39;, &#39; NLP is also good&#39;, &#39;&#39;] print(&#39;\\n&#39;.join(s.split(&#39;.&#39;))) ## Python is great ## NLP is also good print(&#39;\\n&#39;.join([s.strip() for s in s.split(&#39;.&#39;) if s])) ## Python is great ## NLP is also good 3.2 Regular Expressions Regular expressions are a powerful tool for various kinds of string manipulation. They are a domain specific language (DSL) that is present as a library in most modern programming languages, not just Python. Regular expressions in Python can be accessed using the re module, which is part of the standard library. import re s1 = &#39;Python is an excellent language&#39; s2 = &#39;I love the Python language. I also use Python to build applications at work!&#39; 3.2.1 Match &amp; Find The match() function only returns a match if a match is found at the beginning of the string s1. pattern = &#39;python&#39; re.match(pattern, s1), re.match(pattern, s1, flags=re.IGNORECASE) ## (None, &lt;re.Match object; span=(0, 6), match=&#39;Python&#39;&gt;) pattern is in lower case, hence ignore case flag helps in matching same pattern with different cases. Other functions to match patterns are re.search() and re.findall(). The function re.search() finds a match of a pattern anywhere in the string. The function re.findall() returns a list of all substrings that match a pattern. re.search(pattern, s2, re.IGNORECASE) ## &lt;re.Match object; span=(11, 17), match=&#39;Python&#39;&gt; re.findall(pattern, s2, re.IGNORECASE) ## [&#39;Python&#39;, &#39;Python&#39;] There is also re.finditer() which does the same, except it returns an iterator rather than a list print(f&#39;String: {s2}&#39;) ## String: I love the Python language. I also use Python to build applications at work! for m in re.finditer(pattern, s2, re.IGNORECASE): print(f&quot;Found match &#39;{m.group(0)}&#39; ranging from index {m.start()} - {m.end()}&quot;) ## Found match &#39;Python&#39; ranging from index 11 - 17 ## Found match &#39;Python&#39; ranging from index 39 - 45 The regex search returns an object with several methods that give details about it. These methods include group which returns the string matched, start and end which return the start and ending positions of the first match. print(&#39;Found match {} ranging from index {} - {} in the string &quot;{}&quot;&#39;.format( re.match(pattern, s1, flags=re.IGNORECASE).group(0), re.match(pattern, s1, flags=re.IGNORECASE).start(), re.match(pattern, s1, flags=re.IGNORECASE).end(), s1)) ## Found match Python ranging from index 0 - 6 in the string &quot;Python is an excellent language&quot; 3.2.2 Search &amp; Replace One of the most important re methods that use regular expressions is .sub(). This method replaces all occurrences of the pattern in string with repl, substituting all occurrences, unless count provided. This method returns the modified string. re.sub(pattern, &#39;R&#39;, s2, flags=re.IGNORECASE) ## &#39;I love the R language. I also use R to build applications at work!&#39; 3.2.3 Metacharacters Metacharacters are what make regular expressions more powerful than normal string methods. They allow you to create regular expressions to represent concepts like ‚Äúone or more repetitions of a vowel‚Äù. The existence of metacharacters poses a problem if you want to create a regular expression (or regex) that matches a literal metacharacter, such as ‚Äú$‚Äù. You can do this by escaping the metacharacters by putting a backslash in front of them. However, this can cause problems, since backslashes also have an escaping function in normal Python strings. This can mean putting three or four backslashes in a row to do all the escaping. 3.2.3.1 Example: Email Extraction To demonstrate a sample usage of regular expressions, lets create a program to extract email addresses from a string. Suppose we have a text that contains an email address: str = \"Please contact info@sololearn.com for assistance\". Our goal is to extract the substring ‚Äúinfo@sololearn.com‚Äù. A basic email address consists of a word and may include dots or dashes. This is followed by the @ sign and the domain name (the name, a dot, and the domain name suffix). This is the basis for building our regular expression. pattern = r&quot;([\\w\\.-]+)@([\\w\\.-]+)(\\.[\\w\\.]+)&quot; str = &quot;Please contact info@sololearn.com for assistance&quot; match = re.search(pattern, str) if match: print(match.group()) ## info@sololearn.com [\\w\\.-]+ matches one or more word character, dot or dash. The regex above says that the string should contain a word (with dots and dashes allowed), followed by the @ sign, then another similar word, then a dot and another word. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
